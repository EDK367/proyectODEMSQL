//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Jul 15 15:13:46 CST 2024
//----------------------------------------------------
package sintactico;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java_cup.runtime.Symbol;
import controlSemantico.*;
import java.util.Iterator;
import java.util.Arrays;
import java.util.Map;

/**
 * CUP v0.11a beta 20060608 generated parser.
 *
 * @version Mon Jul 15 15:13:46 CST 2024
 */
public class Sintax extends java_cup.runtime.lr_parser {

    /**
     * Default constructor.
     */
    public Sintax() {
        super();
    }

    /**
     * Constructor which sets the default scanner.
     */
    public Sintax(java_cup.runtime.Scanner s) {
        super(s);
    }

    /**
     * Constructor which sets the default scanner.
     */
    public Sintax(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {
        super(s, sf);
    }

    /**
     * Production table.
     */
    protected static final short _production_table[][]
            = unpackFromStrings(new String[]{
        "\000\035\000\002\002\004\000\002\002\006\000\002\002"
        + "\006\000\002\002\011\000\002\002\004\000\002\011\012"
        + "\000\002\011\003\000\002\011\003\000\002\013\005\000"
        + "\002\013\005\000\002\013\005\000\002\013\004\000\002"
        + "\014\005\000\002\014\005\000\002\014\005\000\002\015"
        + "\003\000\002\015\003\000\002\016\006\000\002\016\015"
        + "\000\002\003\011\000\002\012\003\000\002\006\004\000"
        + "\002\007\005\000\002\007\002\000\002\010\003\000\002"
        + "\010\003\000\002\010\003\000\002\005\011\000\002\005"
        + "\010"});

    /**
     * Access to production table.
     */
    public short[][] production_table() {
        return _production_table;
    }

    /**
     * Parse-action table.
     */
    protected static final short[][] _action_table
            = unpackFromStrings(new String[]{
        "\000\126\000\006\004\004\021\005\001\002\000\004\005"
        + "\126\001\002\000\004\005\116\001\002\000\012\002\015"
        + "\004\011\010\014\021\013\001\002\000\012\002\ufffb\004"
        + "\ufffb\010\ufffb\021\ufffb\001\002\000\012\002\ufffa\004\ufffa"
        + "\010\ufffa\021\ufffa\001\002\000\004\006\050\001\002\000"
        + "\012\002\ufffd\004\ufffd\010\ufffd\021\ufffd\001\002\000\006"
        + "\005\035\006\036\001\002\000\004\006\016\001\002\000"
        + "\004\002\001\001\002\000\004\046\017\001\002\000\004"
        + "\036\uffed\001\002\000\004\036\021\001\002\000\010\030"
        + "\024\031\025\044\026\001\002\000\004\037\033\001\002"
        + "\000\006\037\uffea\040\027\001\002\000\006\037\uffe8\040"
        + "\uffe8\001\002\000\006\037\uffe7\040\uffe7\001\002\000\006"
        + "\037\uffe9\040\uffe9\001\002\000\010\030\024\031\025\044"
        + "\026\001\002\000\004\037\uffec\001\002\000\006\037\uffea"
        + "\040\027\001\002\000\004\037\uffeb\001\002\000\004\041"
        + "\034\001\002\000\012\002\uffee\004\uffee\010\uffee\021\uffee"
        + "\001\002\000\004\036\043\001\002\000\004\036\037\001"
        + "\002\000\004\046\040\001\002\000\004\037\041\001\002"
        + "\000\004\041\042\001\002\000\012\002\uffe5\004\uffe5\010"
        + "\uffe5\021\uffe5\001\002\000\004\046\044\001\002\000\004"
        + "\037\045\001\002\000\004\006\046\001\002\000\004\041"
        + "\047\001\002\000\012\002\uffe6\004\uffe6\010\uffe6\021\uffe6"
        + "\001\002\000\004\046\051\001\002\000\004\036\052\001"
        + "\002\000\004\046\054\001\002\000\006\033\070\046\067"
        + "\001\002\000\010\042\056\043\055\045\057\001\002\000"
        + "\006\022\061\023\062\001\002\000\006\022\061\023\062"
        + "\001\002\000\006\022\061\023\062\001\002\000\006\033"
        + "\ufff8\046\ufff8\001\002\000\006\033\ufff2\046\ufff2\001\002"
        + "\000\006\033\ufff1\046\ufff1\001\002\000\006\033\ufff7\046"
        + "\ufff7\001\002\000\006\033\ufff9\046\ufff9\001\002\000\006"
        + "\033\ufff6\046\ufff6\001\002\000\006\034\103\037\102\001"
        + "\002\000\010\042\075\043\074\045\076\001\002\000\004"
        + "\036\071\001\002\000\004\046\072\001\002\000\004\037"
        + "\073\001\002\000\006\034\ufff0\037\ufff0\001\002\000\006"
        + "\022\061\023\062\001\002\000\006\022\061\023\062\001"
        + "\002\000\006\022\061\023\062\001\002\000\006\033\ufff4"
        + "\046\ufff4\001\002\000\006\033\ufff3\046\ufff3\001\002\000"
        + "\006\033\ufff5\046\ufff5\001\002\000\004\041\115\001\002"
        + "\000\004\036\104\001\002\000\004\046\105\001\002\000"
        + "\004\037\106\001\002\000\004\020\107\001\002\000\004"
        + "\036\110\001\002\000\004\046\111\001\002\000\004\037"
        + "\112\001\002\000\004\015\113\001\002\000\004\046\114"
        + "\001\002\000\006\034\uffef\037\uffef\001\002\000\012\002"
        + "\ufffc\004\ufffc\010\ufffc\021\ufffc\001\002\000\006\036\120"
        + "\046\117\001\002\000\004\041\125\001\002\000\004\046"
        + "\121\001\002\000\004\037\122\001\002\000\004\006\123"
        + "\001\002\000\004\041\124\001\002\000\012\002\ufffe\004"
        + "\ufffe\010\ufffe\021\ufffe\001\002\000\012\002\uffff\004\uffff"
        + "\010\uffff\021\uffff\001\002\000\004\046\127\001\002\000"
        + "\004\041\130\001\002\000\012\002\000\004\000\010\000"
        + "\021\000\001\002"});

    /**
     * Access to parse-action table.
     */
    public short[][] action_table() {
        return _action_table;
    }

    /** <code>reduce_goto</code> table.
     */
    protected static final short[][] _reduce_table
            = unpackFromStrings(new String[]{
        "\000\126\000\004\002\005\001\001\000\002\001\001\000"
        + "\002\001\001\000\010\003\006\005\007\011\011\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\004\012\017\001\001\000\002\001\001\000"
        + "\002\001\001\000\006\006\021\010\022\001\001\000\002"
        + "\001\001\000\004\007\027\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\004\010\030\001\001"
        + "\000\002\001\001\000\004\007\031\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\004\013\052"
        + "\001\001\000\006\014\064\016\065\001\001\000\002\001"
        + "\001\000\004\015\063\001\001\000\004\015\062\001\001"
        + "\000\004\015\057\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\004\015\100\001\001\000\004\015\077\001"
        + "\001\000\004\015\076\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001\000\002\001\001\000\002"
        + "\001\001\000\002\001\001\000\002\001\001\000\002\001"
        + "\001\000\002\001\001\000\002\001\001\000\002\001\001"
        + "\000\002\001\001\000\002\001\001\000\002\001\001\000"
        + "\002\001\001\000\002\001\001"});

    /**
     * Access to <code>reduce_goto</code> table.
     */
    public short[][] reduce_table() {
        return _reduce_table;
    }

    /**
     * Instance of action encapsulation class.
     */
    protected CUP$Sintax$actions action_obj;

    /**
     * Action encapsulation object initializer.
     */
    protected void init_actions() {
        action_obj = new CUP$Sintax$actions(this);
    }

    /**
     * Invoke a user supplied parse action.
     */
    public java_cup.runtime.Symbol do_action(
            int act_num,
            java_cup.runtime.lr_parser parser,
            java.util.Stack stack,
            int top)
            throws java.lang.Exception {
        /* call code in generated class */
        return action_obj.CUP$Sintax$do_action(act_num, parser, stack, top);
    }

    /**
     * Indicates start state.
     */
    public int start_state() {
        return 0;
    }

    /**
     * Indicates start production.
     */
    public int start_production() {
        return 0;
    }

    /** <code>EOF</code> Symbol index.
     */
    public int EOF_sym() {
        return 0;
    }

    /** <code>error</code> Symbol index.
     */
    public int error_sym() {
        return 1;
    }

    private static int keyID = -1;
    private static int keyDatas = -1;
    private static int keyDataBase;
    private static int keyTable;
    private static int keyData;
    private int keyTableDatos;
    private String keyNameTable;
    private static boolean keyDataIsNull;
    private static HashMap<Integer, List<Object>> map = new HashMap<>();
    private static HashMap<String, HashMap<Integer, List<Object>>> mapDatas = new HashMap<>();
    private HashMap<Integer, List<Object>> mapDatosIngresados = new HashMap<>();
    private HashMap<String, List<Object>> mapShow = new HashMap<>();
    private List<Object> listValores = new ArrayList<>();
    private List<Object> listTablas = new ArrayList<>();
    private static List<Integer> listData = new ArrayList<>();
    public Symbol s;

    public HashMap<Integer, List<Object>> getMap() {
        return map;
    }

    public HashMap<String, HashMap<Integer, List<Object>>> getMapDatas() {
        return mapDatas;
    }

    public HashMap<String, List<Object>> getMapShow() {
        return mapShow;
    }

    public void syntax_error(Symbol s) {
        this.s = s;
    }

    public Symbol getS() {
        return this.s;
    }

    // Funcion para generar una nueva key para el HashMap
    private int keyMap() {
        return ++keyID;
    }
    
    private int keyDatas() {
        return ++keyDatas;
    }

    //Funcion para buscar la tabla y usarla en las listas
    public void tableExist(Object nameTable) throws SemanticErrorException {
        for (Map.Entry<Integer, List<Object>> entry : map.entrySet()) {
            List<Object> list = entry.getValue();
            if (list.size() == 5 && "Tabla".equals(list.get(1))) {
                if (nameTable.equals(list.get(2))
                        && (list.get(4) instanceof Integer && (Integer) list.get(4) == keyDataBase)) {
                    listTablas.add(list);
                    keyNameTable = (String) list.get(2);
                    keyTableDatos = (int) list.get(0);
                    break;
                }
            }
        }
        if (listTablas.isEmpty()) {
            throw new SemanticErrorException("No existe en la base de datos la siguiente tabla: " + nameTable);
        }
    }

    //Funcion para ingresar los datos en un arrayList para almacenar cada uno de los distintos valores
    public void ingresoDatos(String valor) {
        char tipo = valor.charAt(0);
        if (Character.isDigit(tipo)) {
            listValores.add(List.of("int", valor));
        }
        switch (tipo) {
            case '"' ->
                listValores.add(List.of("string", valor));
            case '\'' ->
                listValores.add(List.of("char", valor));
        }
    }

    //Funcion para compara los datos de la tabla
    public void estrucData() throws SemanticErrorException {
        List<Object> listDatos = new ArrayList<>();
        List<Object> listFinal = new ArrayList<>();
        for (Map.Entry<Integer, List<Object>> entry : map.entrySet()) {
            List<Object> list = entry.getValue();
            if (list.size() == 7 && "Dato".equals(list.get(1))) {
                if (list.get(5) instanceof Integer && (Integer) list.get(5) == keyTableDatos) {
                    listDatos.add(list.get(3));
                }
            }
        }
        if (listDatos.size() == listValores.size()) {
            int contador = 0;
            for (int i = 0; i < listValores.size(); i++) {
                List<Object> sublista = (List<Object>) listValores.get(i);
                Object primerElemento = sublista.get(0);
                Object elementoReferencia = listDatos.get(i);
                if (primerElemento.equals(elementoReferencia)) {
                    contador++;
                } else {
                    throw new SemanticErrorException("Existe un error en el ingreso correcto de "
                            + "datos en la tabla: " + keyNameTable);
                }
            }
            if (contador == listDatos.size()) {
                for (Object elemento : listValores) {
                    List<Object> list = (List<Object>) elemento;
                    listFinal.add(list.get(1));
                }
                int key = keyDatas();
                mapDatosIngresados.put(key, listFinal);
                System.out.println("map" + mapDatosIngresados);
                mapDatas.put(keyNameTable, mapDatosIngresados);
                
                listValores.clear();
                mapDatosIngresados.clear();
            } else {
                System.out.println("llego aca");
                throw new SemanticErrorException("Se ha ingresado mas o menos valores de los que contiene la tabla " + keyNameTable);
            }

        } else {
            listDatos.clear();
            listValores.clear();
            throw new SemanticErrorException("Se ha ingresado mas o menos valores de los que contiene la tabla " + keyNameTable);
        }
    }

    //Funcion para hacer el show de las tablas
    public void showTables(Object nameDataBase, String show) throws SemanticErrorException {
        if (show.equals("Tablas")) {
            List<Object> listFromBase = new ArrayList<>();
            dataBaseInUse(nameDataBase);
            for (Map.Entry<Integer, List<Object>> entry : map.entrySet()) {
                List<Object> list = entry.getValue();
                if (list.size() == 5 && "Tabla".equals(list.get(1))) {
                    if ((list.get(4) instanceof Integer) && (Integer) list.get(4) == keyDataBase) {
                        listFromBase.add(list);
                    }
                }
            }
            mapShow.put((String) nameDataBase, listFromBase);
        } else if (show.equals("Datos")) {
            List<Object> listShow = new ArrayList<>();
            for (Map.Entry<String, HashMap<Integer, List<Object>>> entry : mapDatas.entrySet()) {
                System.out.println("value " + entry.getValue());
                
                
            }
            

            
        }
    }

    //Funcion para valor nulo
    public void isDataNull(boolean isNull) {
        if (isNull) {
            keyDataIsNull = true;
        } else {
            keyDataIsNull = false;
        }
    }

    //Funciones para crear los List necesarios con los datos para poder crear el semantico
    private List<Object> dataBases(Object name) {
        List<Object> nameBase = new ArrayList<>();
        nameBase.add("Base de Datos");
        nameBase.add(name);
        return nameBase;
    }

    private List<Object> tables(Object name, int ID) {
        List<Object> nameTable = new ArrayList<>();
        nameTable.add(ID);
        nameTable.add("Tabla");
        nameTable.add(name);
        nameTable.add(listData.size());
        nameTable.add(keyDataBase);
        return nameTable;
    }

    private List<Object> datas(Object nameTable, int ID, Object tipoDato) {
        List<Object> nameData = new ArrayList<>();
        listData.add(ID);
        nameData.add(ID);
        nameData.add("Dato");
        nameData.add(nameTable);
        nameData.add(tipoDato);
        nameData.add(keyDataIsNull);
        nameData.add(keyTable);
        nameData.add(keyDataBase);
        return nameData;
    }

    //funcion para insertar la base de datos en el HashMap
    public void putBase(Object name) throws SemanticErrorException {
        keyDataBase = keyMap();
        if (!buscador("Base de Datos", (String) name, keyDataBase)) {
            map.put(keyDataBase, dataBases(name));
        } else {
            keyID--;
            throw new SemanticErrorException("Ya existe una base de Datos con el mismo nombre: " + name);
        }
    }

    //funcion para insertar tables en el HasMap
    public void putTable(Object nameTable) throws SemanticErrorException {
        keyTable = keyMap();
        map.put(keyTable, tables(nameTable, keyTable));
        for (int i = 0; i < listData.size(); i++) {
            int indice = listData.get(i);
            List<Object> newList = map.get(indice);
            newList.set(5, keyTable);
        }
        listData.clear();
        if (buscador("Tabla", (String) nameTable, keyTable)) {
            int retroceso = 1;
            map.remove(keyTable);
            Iterator<Map.Entry<Integer, List<Object>>> iterator = map.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry<Integer, List<Object>> entry = iterator.next();
                List<Object> list = entry.getValue();
                if ("Dato".equals(list.get(1))
                        && (list.get(5) instanceof Integer && (Integer) list.get(5) == keyTable)
                        && (list.get(6) instanceof Integer && (Integer) list.get(6) == keyDataBase)) {
                    iterator.remove();
                    retroceso++;
                }
            }
            keyID -= retroceso;
            throw new SemanticErrorException("Ya existe una tabla con el mismo nombre: " + nameTable);
        }
    }

    //funcion para insertar datos de las tablas en el HasMap
    public void putData(Object nameData, Object tipoData) {
        keyData = keyMap();
        map.put(keyData, datas(nameData, keyData, tipoData));
    }

    //funcion para usar la dataBase
    public void dataBaseInUse(Object nameDataBase) throws SemanticErrorException {
        boolean baseDeDatosEncontrada = false;
        if (!map.isEmpty()) {
            for (Map.Entry<Integer, List<Object>> entry : map.entrySet()) {
                List<Object> list = entry.getValue();
                if (list.size() == 2) {
                    if (nameDataBase.equals(list.get(1))) {
                        keyDataBase = entry.getKey();
                        baseDeDatosEncontrada = true;
                        break;
                    }
                }
            }
            if (!baseDeDatosEncontrada) {
                throw new SemanticErrorException("No existe esta base de Datos: " + nameDataBase);
            }
        } else {
            listData.clear();
            throw new SemanticErrorException("No existe esta base de Datos: " + nameDataBase);
        }
    }

    //Funcion para buscar si existe
    private boolean buscador(String tipo, String name, int key) {
        if (tipo.equals("Tabla")) {
            for (Map.Entry<Integer, List<Object>> entry : map.entrySet()) {
                List<Object> list = entry.getValue();
                if (list.size() == 5 && tipo.equals(list.get(1))) {
                    if (name.equals(list.get(2)) && (list.get(0) instanceof Integer && (Integer) list.get(0) != key)
                            && (list.get(4) instanceof Integer && (Integer) list.get(4) == keyDataBase)) {
                        return true;
                    }
                }
            }
        } else if (tipo.equals("Dato")) {
        } else if (tipo.equals("Base de Datos")) {
            for (Map.Entry<Integer, List<Object>> entry : map.entrySet()) {
                List<Object> list = entry.getValue();
                if (list.size() == 2 && tipo.equals(list.get(0))) {
                    if (name.equals(list.get(1))) {
                        int keyData = entry.getKey();
                        if (keyData != key) {
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

}

/**
 * Cup generated class to encapsulate user supplied action code.
 */
class CUP$Sintax$actions {

    private final Sintax parser;

    /**
     * Constructor
     */
    CUP$Sintax$actions(Sintax parser) {
        this.parser = parser;
    }

    /**
     * Method with the actual generated action code.
     */
    public final java_cup.runtime.Symbol CUP$Sintax$do_action(
            int CUP$Sintax$act_num,
            java_cup.runtime.lr_parser CUP$Sintax$parser,
            java.util.Stack CUP$Sintax$stack,
            int CUP$Sintax$top)
            throws java.lang.Exception {
        /* Symbol object for return from actions */
        java_cup.runtime.Symbol CUP$Sintax$result;

        /* select the action based on the action number */
        switch (CUP$Sintax$act_num) {
            /*. . . . . . . . . . . . . . . . . . . .*/
            case 28: // VISTA ::= SHOW TABLE LPAREN IDENTIFICADOR RPAREN PCOMA 
            {
                Object RESULT = null;
                int nameVistaDataleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).left;
                int nameVistaDataright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).right;
                Object nameVistaData = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value;
                parser.showTables(nameVistaData, "Datos");
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("VISTA", 3, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 5)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 27: // VISTA ::= SHOW DATABASE LPAREN IDENTIFICADOR RPAREN TABLE PCOMA 
            {
                Object RESULT = null;
                int nameDataBaseleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)).left;
                int nameDataBaseright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)).right;
                Object nameDataBase = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)).value;
                parser.showTables(nameDataBase, "Tablas");
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("VISTA", 3, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 6)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 26: // DATOS ::= ISSTRING 
            {
                Object RESULT = null;
                int valorleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).left;
                int valorright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).right;
                Object valor = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).value;
                parser.ingresoDatos((String) valor);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DATOS", 6, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 25: // DATOS ::= ISCHAR 
            {
                Object RESULT = null;
                int valorleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).left;
                int valorright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).right;
                Object valor = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).value;
                parser.ingresoDatos((String) valor);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DATOS", 6, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 24: // DATOS ::= DIGIT 
            {
                Object RESULT = null;
                int valorleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).left;
                int valorright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).right;
                Object valor = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).value;
                parser.ingresoDatos((String) valor);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DATOS", 6, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 23: // LISTA_DATOS2 ::= 
            {
                Object RESULT = null;
                parser.estrucData();
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("LISTA_DATOS2", 5, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 22: // LISTA_DATOS2 ::= CONCAT DATOS LISTA_DATOS2 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("LISTA_DATOS2", 5, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 21: // LISTA_DATOS ::= DATOS LISTA_DATOS2 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("LISTA_DATOS", 4, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 20: // TABLE_NAME ::= IDENTIFICADOR 
            {
                Object RESULT = null;
                int nameTableleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).left;
                int nameTableright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).right;
                Object nameTable = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()).value;
                parser.tableExist(nameTable);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("TABLE_NAME", 8, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 19: // INSERCION ::= INSERT TABLE TABLE_NAME LPAREN LISTA_DATOS RPAREN PCOMA 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("INSERCION", 1, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 6)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 18: // KEY ::= KEY SECONDKEY LPAREN IDENTIFICADOR RPAREN REFERENCES LPAREN IDENTIFICADOR RPAREN FROM IDENTIFICADOR 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("KEY", 12, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 10)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 17: // KEY ::= PRIMARYKEY LPAREN IDENTIFICADOR RPAREN 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("KEY", 12, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 16: // NULO ::= NONULL 
            {
                Object RESULT = null;
                boolean isNoNull = true;
                parser.isDataNull(isNoNull);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("NULO", 11, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 15: // NULO ::= NULL 
            {
                Object RESULT = null;
                boolean isNull = false;
                parser.isDataNull(isNull);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("NULO", 11, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 14: // DECLARACION2 ::= IDENTIFICADOR CHAR NULO 
            {
                Object RESULT = null;
                int nameDataleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).left;
                int nameDataright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).right;
                Object nameData = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value;
                int tleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object t = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                parser.putData(nameData, t);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DECLARACION2", 10, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 13: // DECLARACION2 ::= IDENTIFICADOR INT NULO 
            {
                Object RESULT = null;
                int nameDataleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).left;
                int nameDataright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).right;
                Object nameData = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value;
                int tleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object t = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                parser.putData(nameData, t);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DECLARACION2", 10, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 12: // DECLARACION2 ::= IDENTIFICADOR STRING NULO 
            {
                Object RESULT = null;
                int nameDataleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).left;
                int nameDataright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).right;
                Object nameData = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value;
                int tleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object t = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                parser.putData(nameData, t);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DECLARACION2", 10, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 11: // DECLARACION ::= DECLARACION DECLARACION2 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DECLARACION", 9, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 10: // DECLARACION ::= IDENTIFICADOR CHAR NULO 
            {
                Object RESULT = null;
                int nameDataleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).left;
                int nameDataright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).right;
                Object nameData = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value;
                int tleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object t = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                parser.putData(nameData, t);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DECLARACION", 9, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 9: // DECLARACION ::= IDENTIFICADOR INT NULO 
            {
                Object RESULT = null;
                int nameDataleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).left;
                int nameDataright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).right;
                Object nameData = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value;
                int tleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object t = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                parser.putData(nameData, t);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DECLARACION", 9, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 8: // DECLARACION ::= IDENTIFICADOR STRING NULO 
            {
                Object RESULT = null;
                int nameDataleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).left;
                int nameDataright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).right;
                Object nameData = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)).value;
                int tleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int tright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object t = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                parser.putData(nameData, t);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("DECLARACION", 9, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 2)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 7: // SENTENCIA ::= VISTA 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("SENTENCIA", 7, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 6: // SENTENCIA ::= INSERCION 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("SENTENCIA", 7, ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 5: // SENTENCIA ::= CREATE TABLE IDENTIFICADOR LPAREN DECLARACION KEY RPAREN PCOMA 
            {
                Object RESULT = null;
                int nameTableleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 5)).left;
                int nameTableright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 5)).right;
                Object nameTable = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 5)).value;
                parser.putTable(nameTable);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("SENTENCIA", 7, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 7)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 4: // INICIO ::= INICIO SENTENCIA 
            {
                Object RESULT = null;

                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("INICIO", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 3: // INICIO ::= SHOW DATABASE LPAREN IDENTIFICADOR RPAREN TABLE PCOMA 
            {
                Object RESULT = null;
                int nameDataBaseleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)).left;
                int nameDataBaseright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)).right;
                Object nameDataBase = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)).value;
                parser.showTables(nameDataBase, "Tablas");
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("INICIO", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 6)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 2: // INICIO ::= SHOW DATABASE IDENTIFICADOR PCOMA 
            {
                Object RESULT = null;
                int nameleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int nameright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object name = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                parser.dataBaseInUse(name);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("INICIO", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 1: // INICIO ::= CREATE DATABASE IDENTIFICADOR PCOMA 
            {
                Object RESULT = null;
                int nameleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int nameright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object name = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                parser.putBase(name);
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("INICIO", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 3)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            return CUP$Sintax$result;

            /*. . . . . . . . . . . . . . . . . . . .*/
            case 0: // $START ::= INICIO EOF 
            {
                Object RESULT = null;
                int start_valleft = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).left;
                int start_valright = ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).right;
                Object start_val = (Object) ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)).value;
                RESULT = start_val;
                CUP$Sintax$result = parser.getSymbolFactory().newSymbol("$START", 0, ((java_cup.runtime.Symbol) CUP$Sintax$stack.elementAt(CUP$Sintax$top - 1)), ((java_cup.runtime.Symbol) CUP$Sintax$stack.peek()), RESULT);
            }
            /* ACCEPT */
            CUP$Sintax$parser.done_parsing();
            return CUP$Sintax$result;

            /* . . . . . .*/
            default:
                throw new Exception(
                        "Invalid action number found in internal parse table");

        }
    }
}
